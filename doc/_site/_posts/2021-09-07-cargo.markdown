---
layout: post
title: Cargo
date: 2021-09-07
categories: contabilidad
---
# Cargo


En el post anterior esbozamos la regla para cargar una cuenta. Ahora le muestro el código que a mí me funcionó bien.

{% highlight CLIPS %}
(deftemplate cargo
   (slot monto (default 0))
   (slot realizado (default false))
)

(deftemplate cuenta
   (slot debe (default 0))
)

(defrule cargar-cuenta-existente
   ?cargo  <-  ( cargo (monto ?monto) )
   ?cuenta <-  ( cuenta (debe ?debe)  )
  =>
   ( halt )
   ( modify ?cuenta (debe ( round (+ ?debe ?monto)) ))
   ( modify ?cargo  (realizado true))
   ( printout t "c-->" tab ?monto tab "|" tab 0 tab crlf)
)

(defrule inicio
  (declare (salience 10000))
  =>
  ( watch facts)
  ( assert (cuenta (debe 0)))
  ( assert (cargo (monto 100)))
)

{% endhighlight %}

Y la salida en pantalla correspondiente es:

{% highlight CLIPS %}
Defining deftemplate: cargo
Defining deftemplate: cuenta
Defining defrule: cargar-cuenta-existente +j+j+j
Defining defrule: inicio +j+j
==> f-1     (cuenta (debe 0))
==> f-2     (cargo (monto 100) (realizado false))
<== f-1     (cuenta (debe 0))
==> f-3     (cuenta (debe 100))
<== f-2     (cargo (monto 100) (realizado false))
==> f-4     (cargo (monto 100) (realizado true))
c-->	100	|	0	
{% endhighlight %}

Ud. puede hacer lo mismo si instala **CLIPS**, consulte en [Clips](http://www.clipsrules.net/).

Clique aqui para bajar el archivo [micro.clp](/micro.clp)

### Análisis
---
Ojalá que pueda imprimir el documento *micro.clp* para que hacer anotaciones sobre él código en la medida que lo analizamos en conjunto. También sirve si tuviera dos dispositivos. Siempre conviene tener dos pantallas cuando uno hace programas.

En *micro.clp* entonces:
- [x] Hay *templates* que definen las estructuras de los hechos que necesitamos para disparar la regla de cargo.

Hecho| Campo | Valor Inicial | Campo    | Valor Inicial
-----|----- | ------         | ---      |----
Cargo| monto | 0             | realizado | false
Cuenta| debe | false         

La función de los campos es:

Campo | Función
------|---------
Monto | Valor de dinero que se quiere cargar
Realizado | Valor que indica si el cargo fue realizado o no
Debe | Valor que la contabilidad asigna a una cuenta para su lado izquierdo


{% highlight CLIPS %}
(deftemplate cargo
   (slot monto (default 0))
   (slot realizado (default false))
)

(deftemplate cuenta
   (slot debe (default 0))
)
{% endhighlight %}

En micro.clp se definen dos reglas
- [x] cargar-cuenta-existente
- [x] inicio

#### Reglas

Nombre | LHS | RHS
-------|-----|------
cargar-cuenta-existente | cargo  | (modify cuenta)
                        | cuenta | (modify cargo)
                        |        | (printout t ?monto)
inicio                  |        | (assert cuenta)
                        |        | (assert cargo)

{% highlight CLIPS %}

(defrule cargar-cuenta-existente
   ?cargo  <-  ( cargo (monto ?monto) )
   ?cuenta <-  ( cuenta (debe ?debe)  )
  =>
   ( halt )
   ( modify ?cuenta (debe ( round (+ ?debe ?monto)) ))
   ( modify ?cargo  (realizado true))
   ( printout t "c-->" tab ?monto tab "|" tab 0 tab crlf)
)

(defrule inicio
  (declare (salience 10000))
  =>
  ( watch facts)
  ( assert (cuenta (debe 0)))
  ( assert (cargo (monto 100)))
)

{% endhighlight %}

La regla inicio  no tiene hechos en su lado izquierdo pero aún así se dispara porque es una regla especial que se activa con el comando **(reset)**.

En *inicio* hacemos lo que queremos que pase antes, nos interesa disparar la regla *cargar-cuenta-existente* que depende de dos hechos, entonces esos hechos los activamos en la regla *inicio* y para ver que eso realmente sea lo que pase, colocamos un vigilante **watch facts** que escribirá indicando si los hechos son subidos a la memoria (==>) o eliminados de esta (<==).


- [x] (watch facts) muestra lo que le pasa a los hechos (en inglés --facts--)
- [x] ( assert (cuenta (debe 0))): sube a la memoria el hecho cuenta
- [x] ( assert (cargo (monto 100))): sube a la memoria el hecho cargo con un monto de 100

En la regla *cargar-cuenta-existente* hemos colocado un comando **(halt)** para detener el sistema una vez que la regla se dispare.

Eso es todo lo que podemos analizar en *micro.clp*. Este código se usa en **CLIPS** de esta forma:
- [x] (load micro.clp)
- [x] (reset )
- [x] (run)


Después de que usted termine de digitar **(run)**. Sucederá la impresión en pantalla siguiente:

{% highlight CLIPS %}
Defining deftemplate: cargo
Defining deftemplate: cuenta
Defining defrule: cargar-cuenta-existente +j+j+j
Defining defrule: inicio +j+j
==> f-1     (cuenta (debe 0))
==> f-2     (cargo (monto 100) (realizado false))
<== f-1     (cuenta (debe 0))
==> f-3     (cuenta (debe 100))
<== f-2     (cargo (monto 100) (realizado false))
==> f-4     (cargo (monto 100) (realizado true))
c-->    100     |       0
{% endhighlight %}

# Análisis
---
La salida en pantalla es muy concisa y cuesta entenderla cuando se ve por primera vez, pero con un poco de ayuda seguramente Ud. comenzará finalmente a entender cómo funciona su primer expert system contable.

- [x] Defining deftemplate: .....: Nos informa que las estructuras de los hechos han sido entendidas por **CLIPS** y procesadas para aceptar hechos con esa estructura
- [x] ==> f-1 (cuenta (debe 0)): Nos informa que el hecho (cuenta (debe 0)) ha sido ingresado a la memoria
- [x] ==> f-2 (cargo (monto 100) (realizado false)): Nos informa que el hecho cargo con monto 100 ha sido cargado a la memoria.

Ambas subidas han sido provocadas por el uso de los comandos *assert* que hemos visto antes, recuerda en qué regla ?

Análisis
---
Ahora concentrémonos en las salidas en pantalla del comando **(watch facts)**, recuerda donde lo pusimos ?

{% highlight CLIPS %}
==> f-1     (cuenta (debe 0))
==> f-2     (cargo (monto 100) (realizado false))
<== f-1     (cuenta (debe 0))
==> f-3     (cuenta (debe 100))
<== f-2     (cargo (monto 100) (realizado false))
==> f-4     (cargo (monto 100) (realizado true))
{% endhighlight %}

**(watch facts)** solo imprime cosas con unas flechas que indican si un hecho está siendo considerado por **CLIPS** o si ya no está en la memoria.

- [x] Ya sabemos lo que significan f-1 y f-2: son el resultado de dos *(assert)* que colocamos en algún lugar. *(assert)* siempre sube a la memoria


- Ya, pero quién baja los hechos  **(<==)** ?
- Los hechos son sacados de memoria y vueltos a colocar modificados pero con otro identificador de hecho (son los f-algo que se ven en cada línea de la lista). El que hace eso es el comando *(modify)*.

## Análisis
---
Concéntremonos en uno de los comandos *( modify)*. Para ello, haremos como si la regla *cargar-cuenta-existente* solo tuviese un *(modify)*.

{% highlight CLIPS %}

(defrule cargar-cuenta-existente
   ?cargo  <-  ( cargo (monto ?monto) )
   ?cuenta <-  ( cuenta (debe ?debe)  )
  =>
   ( modify ?cuenta (debe ( round (+ ?debe ?monto)) ))
)

{% endhighlight %}
 
{% highlight CLIPS %}

<== f-1     (cuenta (debe 0))
==> f-3     (cuenta (debe 100))
{% endhighlight %}

El efecto en aislamiento del comando *(modify (?cuenta) ...)* es sumarle al campo **debe** de la cuenta un monto que ha traído a la regla el hecho **cargo**.

La salida en pantalla muestra que *(modify)* primero descarga el hecho pero solo para volverlo a cargar con el campo **debe** actualizado a **100**.

# Análisis
---
Finalmente analizaremos lo que imprime la regla *(cargar-cuenta-existente)*. Para ello haremos como si la regla solo tuviera el comando *(printout t)*.

{% highlight CLIPS %}

(defrule cargar-cuenta-existente
   ?cargo  <-  ( cargo (monto ?monto) )
   ?cuenta <-  ( cuenta (debe ?debe)  )
  =>
   ( printout t "c-->" tab ?monto tab "|" tab 0 tab crlf)
)

{% endhighlight %}


{% highlight CLIPS %}
c-->    100     |       0
{% endhighlight %}

Bien! La salida de la regla es un aviso de que ha *(cargado)* al **debe** la cuenta.

Si lo piensa bien, lo único que necesitamos de todo esto es lo que nos quiera comunicar la regla, el resto es una forma de entender el funcionamiento del sistema. En general no es necesario seguir tan de cerca lo que sucede. Es un mal hábito de los antiguos sistemas necios de programar. Ahora el sistema es inteligente  y Ud. solo le resta confiar en esa inteligencia, así que Ud. siempre será un gran necio si se compara con un Expert System.


[bienvenido](/contabilidad/2021/09/05/bienvenido.html)|[cuentas](/contabilidad/2021/09/06/cuentas.html)


